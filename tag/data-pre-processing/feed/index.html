<?xml version="1.0" encoding="UTF-8"?><rss version="2.0"
	xmlns:content="http://purl.org/rss/1.0/modules/content/"
	xmlns:wfw="http://wellformedweb.org/CommentAPI/"
	xmlns:dc="http://purl.org/dc/elements/1.1/"
	xmlns:atom="http://www.w3.org/2005/Atom"
	xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
	xmlns:slash="http://purl.org/rss/1.0/modules/slash/"
	>

<channel>
	<title>data pre processing &#8211; 果醬珍珍•JamJam</title>
	<atom:link href="/tag/data-pre-processing/feed/" rel="self" type="application/rss+xml" />
	<link>/</link>
	<description>健忘女孩Jam的學習筆記和生活雜記</description>
	<lastBuildDate>Fri, 03 Jul 2020 02:33:23 +0000</lastBuildDate>
	<language>zh-TW</language>
	<sy:updatePeriod>
	hourly	</sy:updatePeriod>
	<sy:updateFrequency>
	1	</sy:updateFrequency>
	<generator>https://wordpress.org/?v=5.7.2</generator>
	<item>
		<title>資料處理-實用的10個小技巧 &#124; Data Processing Basics FAQ &#124; R 語言</title>
		<link>/r-data-processing-top-10-faq-%e8%b3%87%e6%96%99%e8%99%95%e7%90%86/</link>
					<comments>/r-data-processing-top-10-faq-%e8%b3%87%e6%96%99%e8%99%95%e7%90%86/#respond</comments>
		
		<dc:creator><![CDATA[jamleecute]]></dc:creator>
		<pubDate>Sat, 01 Sep 2018 08:09:49 +0000</pubDate>
				<category><![CDATA[ 程式與統計]]></category>
		<category><![CDATA[資料處理]]></category>
		<category><![CDATA[data frame]]></category>
		<category><![CDATA[data pre processing]]></category>
		<category><![CDATA[data processing]]></category>
		<category><![CDATA[R]]></category>
		<guid isPermaLink="false">/?p=1736</guid>

					<description><![CDATA[<p>本篇整理了使用R語言進行 資料處理(Data Processing) 的 Top 10 FAQ，為了節省健忘的自己反覆google stackoverflow的 [&#8230;]</p>
<p>這篇文章 <a rel="nofollow" href="/r-data-processing-top-10-faq-%e8%b3%87%e6%96%99%e8%99%95%e7%90%86/">資料處理-實用的10個小技巧 | Data Processing Basics FAQ | R 語言</a> 最早出現於 <a rel="nofollow" href="/">果醬珍珍•JamJam</a>。</p>
]]></description>
										<content:encoded><![CDATA[<p>本篇整理了使用R語言進行 資料處理(Data Processing) 的 Top 10 FAQ，為了節省健忘的自己反覆google stackoverflow的時間，想要把常見的 資料處理 語法筆記下來。包括資料欄位重新命名、產生隨機亂數、產生data frame、數值區隔化(binning)、資料萃取等。</p>
<h3>資料處理 Data Processing 實用的10個小技巧</h3>
<h4>1. 產生均一分佈(uniform distribution)和常態分佈(normal distribution)的隨機數值(n=100)</h4>
<p>產生100個均一分佈(uniform distribution)的隨機數值向量（並使用種子參數，固定隨機結果）</p><pre class="crayon-plain-tag">set.seed(125)
(vector1 &lt;- runif(n = 100, min = 50, max = 100))
# [1] 91.23372 55.84255 64.98903 67.82804 98.25975 98.37803 76.65462 66.60778 82.69219 80.72748 50.70648 88.16897 67.96526 55.06754
# [15] 77.83986 71.21092 70.96414 96.67055 83.60329 87.93464 68.69401 86.41751 84.19229 64.76608 78.88808 53.22125 88.13211 56.14755
# [29] 58.42466 50.32025 87.44001 52.76610 97.55393 73.19850 94.65054 80.09208 52.96008 54.36781 94.07018 71.41990 85.78686 64.34257
# [43] 93.64899 63.62392 55.36854 78.86193 87.65080 77.84359 65.02133 75.92287 82.07423 84.34672 51.64452 73.84293 85.64133 67.92616
# [57] 90.67720 50.76088 82.69066 69.70544 76.52618 91.38894 99.59023 80.40770 59.27992 55.20893 88.90397 95.32379 97.02632 68.20486
# [71] 93.56424 96.10821 70.03725 96.28664 56.70781 86.41269 94.10011 60.09537 52.10116 75.80777 78.15360 98.07568 62.58464 76.18880
# [85] 91.73484 91.92365 53.81340 97.19763 88.37050 92.86988 67.39574 80.36109 60.43717 83.97030 65.76207 64.23523 96.80940 95.01764
# [99] 62.68376 60.57814</pre><p>檢視此分佈次數長條圖</p><pre class="crayon-plain-tag">hist(vector1)</pre><p><img loading="lazy" class="alignnone size-full wp-image-1739" src="/wp-content/uploads/2018/09/Rplot01-2.jpeg" alt="資料處理" width="700" height="773" srcset="/wp-content/uploads/2018/09/Rplot01-2.jpeg 700w, /wp-content/uploads/2018/09/Rplot01-2-272x300.jpeg 272w, /wp-content/uploads/2018/09/Rplot01-2-230x254.jpeg 230w, /wp-content/uploads/2018/09/Rplot01-2-350x387.jpeg 350w, /wp-content/uploads/2018/09/Rplot01-2-480x530.jpeg 480w" sizes="(max-width: 700px) 100vw, 700px" /></p>
<p>檢視此分佈的密度機率圖</p><pre class="crayon-plain-tag">plot(density(vector1))</pre><p><img loading="lazy" class="alignnone size-full wp-image-1740" src="/wp-content/uploads/2018/09/Rplot02-1.jpeg" alt="資料處理" width="700" height="773" srcset="/wp-content/uploads/2018/09/Rplot02-1.jpeg 700w, /wp-content/uploads/2018/09/Rplot02-1-272x300.jpeg 272w, /wp-content/uploads/2018/09/Rplot02-1-230x254.jpeg 230w, /wp-content/uploads/2018/09/Rplot02-1-350x387.jpeg 350w, /wp-content/uploads/2018/09/Rplot02-1-480x530.jpeg 480w" sizes="(max-width: 700px) 100vw, 700px" /></p>
<p>產生100個常態分佈(normal distribution)的隨機數值向量（並使用種子參數，固定隨機結果）。預設的常態平均值為0，標準差為1，我們將之改之為平均數80，標準差20。</p><pre class="crayon-plain-tag"># default的平均數為0標準差為1
set.seed(125)
(vector2 &lt;- rnorm(n = 100,mean = 80, sd = 20))
# [1]  94.570870  98.860533  87.227846 101.200558  94.796854   7.888396  97.381079  53.707525  79.820673  65.226583  83.604616
# [12]  56.674802  71.379024  65.341515  87.235630  58.500588  75.307624 108.529317  67.545379  88.757267  91.186797  80.637498
# [23]  58.256334  67.982055  55.808330  77.750359 112.401569  73.330030  73.434837 100.468880  80.106676  76.615631  84.601009
# [34]  92.579101  88.146062 107.731379 113.084699  83.316553 110.208551  81.149520  79.759604  49.380636 112.434828  87.833169
# [45]  91.378179  97.054735 122.659543  61.942937  25.111649  82.308347  79.105285 109.440641  79.853266  75.837099  82.781623
# [56]  42.761641 102.445376  69.369917 101.587147  66.119959  60.815382  88.419203  86.486531  68.378261  95.710587  91.941595
# [67]  78.080758  61.061284  79.886693  77.463590  82.142727  68.684041  44.079131 113.286471  65.865280  78.415170  79.630492
# [78]  53.089088  82.405446  83.816031  70.476195 123.994033  64.910649  75.873647  88.055012 102.208292  78.195002  74.755952
# [89]  63.820298  83.646523  96.931187  84.085811  27.184622  68.838557  66.301864  61.246448  60.270783  68.055789 109.457474
# [100]  94.410342</pre><p>檢視此分佈次數長條圖</p><pre class="crayon-plain-tag">hist(vector2)</pre><p><img loading="lazy" class="alignnone size-full wp-image-1746" src="/wp-content/uploads/2018/09/Rplot03-3.jpeg" alt="Rplot03" width="700" height="602" srcset="/wp-content/uploads/2018/09/Rplot03-3.jpeg 700w, /wp-content/uploads/2018/09/Rplot03-3-300x258.jpeg 300w, /wp-content/uploads/2018/09/Rplot03-3-230x198.jpeg 230w, /wp-content/uploads/2018/09/Rplot03-3-350x301.jpeg 350w, /wp-content/uploads/2018/09/Rplot03-3-480x413.jpeg 480w" sizes="(max-width: 700px) 100vw, 700px" /></p>
<p>檢視此分佈的密度機率圖</p><pre class="crayon-plain-tag">plot(density(vector2))</pre><p><img loading="lazy" class="alignnone size-large wp-image-1747" src="/wp-content/uploads/2018/09/Rplot04-2.jpeg" alt="Rplot04" width="700" height="602" srcset="/wp-content/uploads/2018/09/Rplot04-2.jpeg 700w, /wp-content/uploads/2018/09/Rplot04-2-300x258.jpeg 300w, /wp-content/uploads/2018/09/Rplot04-2-230x198.jpeg 230w, /wp-content/uploads/2018/09/Rplot04-2-350x301.jpeg 350w, /wp-content/uploads/2018/09/Rplot04-2-480x413.jpeg 480w" sizes="(max-width: 700px) 100vw, 700px" /></p>
<div align="center"><script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><br />
<!-- text & display ads 1 --><br />
<ins class="adsbygoogle" style="display: block;" data-ad-client="ca-pub-7946632597933771" data-ad-slot="8154450369" data-ad-format="auto" data-full-width-responsive="true"></ins><br />
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script></div>
<h4>2. concatenate strings 串連字串 using paste() / paste0()</h4>
<p><span style="color: #9f6ad4;">使用<span style="text-decoration: underline;">paste(),paste0()函數</span>，會先將物件轉換成字元型態(as.character)再合併成新字串</span>。</p>
<p>paste()跟paste0()最大差異就是參數差異如下:</p>
<ul>
<li><span style="color: #9f6ad4;">(1) paste()有sep參數: </span>可以調整合併時的字串間的間隔，預設為空白。</li>
<li><span style="color: #9f6ad4;">(2) paste0()有collapse參數: <span style="color: #333333;">可將所有合併後的新字串合併成一個字串</span></span><span style="color: #333333;">。</span></li>
</ul>
<p>我們因為沒有要將100列的新字串合併成單一新字串，因此單純使用paste()即可。</p>
<p>我們這裡示範將數值串連百分比%符號合成新字串。因為sep預設為空白格，我們將空白拿掉。</p><pre class="crayon-plain-tag">(vector3 &lt;- paste(round(rnorm(100),2),"%", sep = ""))

# [1] "0.46%"  "-1.46%" "0.58%"  "-1.28%" "0.35%"  "1.06%"  "1.65%"  "0.81%"  "0.49%"  "2.48%"  "-0.43%" "-0.26%" "1.57%"  "1.03%" 
# [15] "0.4%"   "0.01%"  "-0.7%"  "-0.16%" "1.43%"  "-1.67%" "0.75%"  "0.49%"  "-0.24%" "1.14%"  "-0.56%" "-0.12%" "1.08%"  "-0.51%"
# [29] "-0.01%" "-0.06%" "-0.43%" "-1.52%" "0.26%"  "1.46%"  "1.09%"  "0.39%"  "-0.85%" "0.08%"  "-0.94%" "0.06%"  "0.79%"  "-0.44%"
# [43] "-0.75%" "-1.04%" "1.44%"  "-1.28%" "-1.39%" "0.1%"   "-0.92%" "1.75%"  "0.61%"  "0.82%"  "-0.8%"  "-1.13%" "0.54%"  "-1.07%"
# [57] "-0.91%" "1%"     "-0.15%" "-2.07%" "0.56%"  "2.27%"  "-2.53%" "-0.38%" "0.86%"  "0.58%"  "-0.58%" "-1.85%" "-0.64%" "-1.24%"
# [71] "-2.18%" "-0.85%" "-1.2%"  "0.05%"  "-1.11%" "-2.7%"  "0.36%"  "-0.77%" "0.56%"  "-0.37%" "0.11%"  "0.76%"  "-0.45%" "-1.3%" 
# [85] "1.8%"   "-0.18%" "1.17%"  "-1.01%" "0.22%"  "-0.17%" "-0.67%" "0.68%"  "1.38%"  "0.67%"  "-2.06%" "0.62%"  "1.17%"  "0.48%" 
# [99] "-1.77%" "-2.4%"</pre><p></p>
<h4>3. 產生時間序列</h4>
<p>可以使用<span style="color: #9f6ad4;">seq.Date()函數</span>，只要設定區間起始日期(from= &#8230;, to=&#8230;)，和間隔(by = <code>"day"</code>, <code>"week"</code>, <code>"month"</code>, <code>"quarter"</code> or <code>"year"</code>)，即可自動產生時間序列。</p><pre class="crayon-plain-tag">(vector4 &lt;- seq.Date(from = as.Date("2018-08-01"), to = as.Date("2018-11-08"), by = "day"))

# [1] "2018-08-01" "2018-08-02" "2018-08-03" "2018-08-04" "2018-08-05" "2018-08-06" "2018-08-07" "2018-08-08" "2018-08-09"
# [10] "2018-08-10" "2018-08-11" "2018-08-12" "2018-08-13" "2018-08-14" "2018-08-15" "2018-08-16" "2018-08-17" "2018-08-18"
# [19] "2018-08-19" "2018-08-20" "2018-08-21" "2018-08-22" "2018-08-23" "2018-08-24" "2018-08-25" "2018-08-26" "2018-08-27"
# [28] "2018-08-28" "2018-08-29" "2018-08-30" "2018-08-31" "2018-09-01" "2018-09-02" "2018-09-03" "2018-09-04" "2018-09-05"
# [37] "2018-09-06" "2018-09-07" "2018-09-08" "2018-09-09" "2018-09-10" "2018-09-11" "2018-09-12" "2018-09-13" "2018-09-14"
# [46] "2018-09-15" "2018-09-16" "2018-09-17" "2018-09-18" "2018-09-19" "2018-09-20" "2018-09-21" "2018-09-22" "2018-09-23"
# [55] "2018-09-24" "2018-09-25" "2018-09-26" "2018-09-27" "2018-09-28" "2018-09-29" "2018-09-30" "2018-10-01" "2018-10-02"
# [64] "2018-10-03" "2018-10-04" "2018-10-05" "2018-10-06" "2018-10-07" "2018-10-08" "2018-10-09" "2018-10-10" "2018-10-11"
# [73] "2018-10-12" "2018-10-13" "2018-10-14" "2018-10-15" "2018-10-16" "2018-10-17" "2018-10-18" "2018-10-19" "2018-10-20"
# [82] "2018-10-21" "2018-10-22" "2018-10-23" "2018-10-24" "2018-10-25" "2018-10-26" "2018-10-27" "2018-10-28" "2018-10-29"
# [91] "2018-10-30" "2018-10-31" "2018-11-01" "2018-11-02" "2018-11-03" "2018-11-04" "2018-11-05" "2018-11-06" "2018-11-07"
# [100] "2018-11-08"</pre><p></p>
<h4>4. 產生data frame</h4>
<p>這邊示範如何自行建置一個二維的data frame，<span style="color: #9f6ad4;">欄位名稱為&#8221;=&#8221;符號左側之名稱</span>。data frame各組成向量可以是不同的資料型態，只要注意向量長度需相同則行。</p><pre class="crayon-plain-tag">df &lt;- data.frame(維度一 = 1: 100, 維度二 = c(letters, LETTERS , rep('a', 48)))
head(df)
#   維度一 維度二
# 1      1      a
# 2      2      b
# 3      3      c
# 4      4      d
# 5      5      e
# 6      6      f

tail(df)
#     維度一 維度二
# 95      95      a
# 96      96      a
# 97      97      a
# 98      98      a
# 99      99      a
# 100    100      a</pre><p></p>
<h4>5. 將不同向量vector 與data frame合併成新的data frame</h4>
<p>使用的是<span style="color: #9f6ad4;">cbind()函數</span>(column bind)。而<span style="color: #9f6ad4;">cbind.data.frame()函數</span>則是事前先把物件都轉換成data frame型態 (as.data.frame())。進行cbind時僅需確保資料長度是相同的。</p><pre class="crayon-plain-tag">df.new &lt;- cbind.data.frame(df,vector1, vector2, vector3, vector4)
head(df.new)
#   維度一 維度二  vector1    vector2 vector3    vector4
# 1      1      a 91.23372  94.570870   0.46% 2018-08-01
# 2      2      b 55.84255  98.860533  -1.46% 2018-08-02
# 3      3      c 64.98903  87.227846   0.58% 2018-08-03
# 4      4      d 67.82804 101.200558  -1.28% 2018-08-04
# 5      5      e 98.25975  94.796854   0.35% 2018-08-05
# 6      6      f 98.37803   7.888396   1.06% 2018-08-06
class(df.new)
# [1] "data.frame"
str(df.new)
# 'data.frame':	100 obs. of  6 variables:
# $ 維度一 : int  1 2 3 4 5 6 7 8 9 10 ...
# $ 維度二 : Factor w/ 52 levels "a","A","b","B",..: 1 3 5 7 9 11 13 15 17 19 ...
# $ vector1: num  91.2 55.8 65 67.8 98.3 ...
# $ vector2: num  94.6 98.9 87.2 101.2 94.8 ...
# $ vector3: Factor w/ 93 levels "-0.01%","-0.06%",..: 61 38 66 35 57 78 88 74 63 93 ...
# $ vector4: Date, format: "2018-08-01" "2018-08-02" "2018-08-03" "2018-08-04" ...</pre><p>（＊若是要將資料列合併，則使用rbind()，此時要注意的就是資料維度要一樣。）</p>
<h4>6. 重新命名資料欄位名稱</h4>
<p>如果遇到欄位名稱太長或是為中文時，會想要重新命名。</p>
<p>全部都重新命名。</p><pre class="crayon-plain-tag">names(df.new) &lt;- c('order','letters','random.uniform', 'random.normal', 'percentage', 'date')
head(df.new)
#   order letters random.uniform random.normal percentage       date
# 1     1       a       91.23372     94.570870      0.46% 2018-08-01
# 2     2       b       55.84255     98.860533     -1.46% 2018-08-02
# 3     3       c       64.98903     87.227846      0.58% 2018-08-03
# 4     4       d       67.82804    101.200558     -1.28% 2018-08-04
# 5     5       e       98.25975     94.796854      0.35% 2018-08-05
# 6     6       f       98.37803      7.888396      1.06% 2018-08-06</pre><p>只取部分欄位進行重新命名。</p><pre class="crayon-plain-tag">names(df.new)[colnames(df.new)=='order'] &lt;- 'row.order'
head(df.new)

#   row.order letters random.uniform random.normal percentage       date
# 1         1       a       91.23372     94.570870      0.46% 2018-08-01
# 2         2       b       55.84255     98.860533     -1.46% 2018-08-02
# 3         3       c       64.98903     87.227846      0.58% 2018-08-03
# 4         4       d       67.82804    101.200558     -1.28% 2018-08-04
# 5         5       e       98.25975     94.796854      0.35% 2018-08-05
# 6         6       f       98.37803      7.888396      1.06% 2018-08-06</pre><p></p>
<div align="center"><script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><br />
<!-- text & display ads 1 --><br />
<ins class="adsbygoogle" style="display: block;" data-ad-client="ca-pub-7946632597933771" data-ad-slot="8154450369" data-ad-format="auto" data-full-width-responsive="true"></ins><br />
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script></div>
<h4>7. 根據資料pattern萃取所需資訊 : using <span style="color: #9f6ad4;">sub()</span></h4>
<p>假設想要萃取percentage欄位的數值資訊，並將資料型態改為數值型。我們使用sub()和as.numeric()。</p>
<p>(*更多<a href="http://astrostatistics.psu.edu/su07/R/html/base/html/grep.html">Pattern Matching and Replacement</a>函數用法介紹)</p><pre class="crayon-plain-tag">df.new$percentage &lt;- as.numeric(sub(pattern = "%",replacement = "",x = df.new$percentage))/100.00
head(df.new)

#   row.order random.uniform random.normal percentage       date
# 1         1       91.23372     94.570870     0.0046 2018-08-01
# 2         2       55.84255     98.860533    -0.0146 2018-08-02
# 3         3       64.98903     87.227846     0.0058 2018-08-03
# 4         4       67.82804    101.200558    -0.0128 2018-08-04
# 5         5       98.25975     94.796854     0.0035 2018-08-05
# 6         6       98.37803      7.888396     0.0106 2018-08-06</pre><p></p>
<h4>8. 連續變數區間化(bin, segmentation) : using <span style="color: #9f6ad4;">cut()</span>。</h4>
<p>比如說年齡資訊，在進行統計分析時，都會將數值組成新的區間以利摘要。</p>
<p>最長使用的函數為<span style="color: #9f6ad4;">cut()系列，包括cut_interval(), cut_number(), cut_width()</span>。</p>
<ul>
<li>cut_interval()：會確保每一個間隔區間(range)是等分的。</li>
<li>cut_number() : 會確保每一組內觀測值數目（幾乎）是相同的。</li>
<li>cut_width() : 會確保每一組的寬度(width)相同，並且能調整長條圖的邊界(boundary)和中心點(center)。</li>
</ul>
<p></p><pre class="crayon-plain-tag">set.seed(423)
df.new$age &lt;- rnorm(n = 100, mean = 50, sd = 20)
df.new$seg.age &lt;- cut_width(x = df.new$age, width = 10, boundary = 0, closed = "left")
table(df.new$seg.age)
# [0,10)  [10,20)  [20,30)  [30,40)  [40,50)  [50,60)  [60,70)  [70,80)  [80,90) [90,100] 
#      1        4       10       16       19       21       16        7        5        1</pre><p>將年齡區間分佈以長條圖畫出。</p><pre class="crayon-plain-tag">plot(df.new$seg.age)</pre><p><img loading="lazy" class="alignnone size-full wp-image-1750" src="/wp-content/uploads/2018/09/Rplot05-2.jpeg" alt="Rplot05" width="885" height="675" srcset="/wp-content/uploads/2018/09/Rplot05-2.jpeg 885w, /wp-content/uploads/2018/09/Rplot05-2-300x229.jpeg 300w, /wp-content/uploads/2018/09/Rplot05-2-768x586.jpeg 768w, /wp-content/uploads/2018/09/Rplot05-2-830x633.jpeg 830w, /wp-content/uploads/2018/09/Rplot05-2-230x175.jpeg 230w, /wp-content/uploads/2018/09/Rplot05-2-350x267.jpeg 350w, /wp-content/uploads/2018/09/Rplot05-2-480x366.jpeg 480w" sizes="(max-width: 885px) 100vw, 885px" /></p>
<h4>9. 刪除不感興趣的資料欄位</h4>
<p>有時在分析時，我們會捨棄一些對分析沒幫著的維度。</p>
<p>我們先隨機產生一個不需要的欄位稱作&#8221;nouse&#8221;</p><pre class="crayon-plain-tag">set.seed(423)
df.new$nouse &lt;- rnorm(n = 100, mean = 70, sd = 30)
head(df.new)
#   row.order letters random.uniform random.normal percentage       date      age seg.age     nouse
# 1         1       a       91.23372     94.570870      0.46% 2018-08-01 25.35967 [20,30)  33.03950
# 2         2       b       55.84255     98.860533     -1.46% 2018-08-02 88.41891 [80,90) 127.62837
# 3         3       c       64.98903     87.227846      0.58% 2018-08-03 35.08060 [30,40)  47.62090
# 4         4       d       67.82804    101.200558     -1.28% 2018-08-04 60.08320 [60,70)  85.12480
# 5         5       e       98.25975     94.796854      0.35% 2018-08-05 24.58924 [20,30)  31.88386
# 6         6       f       98.37803      7.888396      1.06% 2018-08-06 33.34497 [30,40)  45.01745</pre><p>再使用下列指令將該欄位捨棄。</p><pre class="crayon-plain-tag">df.new &lt;- df.new[,!(colnames(df.new)== 'nouse')]
head(df.new)

#   row.order letters random.uniform random.normal percentage       date      age seg.age
# 1         1       a       91.23372     94.570870      0.46% 2018-08-01 25.35967 [20,30)
# 2         2       b       55.84255     98.860533     -1.46% 2018-08-02 88.41891 [80,90)
# 3         3       c       64.98903     87.227846      0.58% 2018-08-03 35.08060 [30,40)
# 4         4       d       67.82804    101.200558     -1.28% 2018-08-04 60.08320 [60,70)
# 5         5       e       98.25975     94.796854      0.35% 2018-08-05 24.58924 [20,30)
# 6         6       f       98.37803      7.888396      1.06% 2018-08-06 33.34497 [30,40)</pre><p></p>
<h4>10. 根據分析目的更換資料欄位順序</h4>
<p>法1: 使用欄位指標column index來重新排列欄位</p><pre class="crayon-plain-tag">df.final &lt;- df.new[c(1,6,2,3,4,5,7,8)]
head(df.final)
#   row.order       date letters random.uniform random.normal percentage      age seg.age
# 1         1 2018-08-01       a       91.23372     94.570870      0.46% 25.35967 [20,30)
# 2         2 2018-08-02       b       55.84255     98.860533     -1.46% 88.41891 [80,90)
# 3         3 2018-08-03       c       64.98903     87.227846      0.58% 35.08060 [30,40)
# 4         4 2018-08-04       d       67.82804    101.200558     -1.28% 60.08320 [60,70)
# 5         5 2018-08-05       e       98.25975     94.796854      0.35% 24.58924 [20,30)
# 6         6 2018-08-06       f       98.37803      7.888396      1.06% 33.34497 [30,40)</pre><p>法2: 使用欄位名稱column name來重新排列欄位</p><pre class="crayon-plain-tag">df.final &lt;- df.new[c('row.order','date','letters','random.uniform','random.normal', 'percentage', 'seg.age', 'age')]
head(df.final)
#   row.order       date letters random.uniform random.normal percentage seg.age      age
# 1         1 2018-08-01       a       91.23372     94.570870      0.46% [20,30) 25.35967
# 2         2 2018-08-02       b       55.84255     98.860533     -1.46% [80,90) 88.41891
# 3         3 2018-08-03       c       64.98903     87.227846      0.58% [30,40) 35.08060
# 4         4 2018-08-04       d       67.82804    101.200558     -1.28% [60,70) 60.08320
# 5         5 2018-08-05       e       98.25975     94.796854      0.35% [20,30) 24.58924
# 6         6 2018-08-06       f       98.37803      7.888396      1.06% [30,40) 33.34497</pre><p></p>
<div align="center"><script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><br />
<!-- text & display ads 1 --><br />
<ins class="adsbygoogle" style="display: block;" data-ad-client="ca-pub-7946632597933771" data-ad-slot="8154450369" data-ad-format="auto" data-full-width-responsive="true"></ins><br />
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script></div>
<hr />
<p>更多資料處理相關學習筆記：</p>
<p><a href="/python-web-crawler-beautifulsoup-%e7%b6%b2%e8%b7%af%e7%88%ac%e8%9f%b2/" target="_blank" rel="noopener">網路爬蟲 Web Crawler | 資料不求人 基礎篇 | using Python BeautifulSoup</a></p>
<p>這篇文章 <a rel="nofollow" href="/r-data-processing-top-10-faq-%e8%b3%87%e6%96%99%e8%99%95%e7%90%86/">資料處理-實用的10個小技巧 | Data Processing Basics FAQ | R 語言</a> 最早出現於 <a rel="nofollow" href="/">果醬珍珍•JamJam</a>。</p>
]]></content:encoded>
					
					<wfw:commentRss>/r-data-processing-top-10-faq-%e8%b3%87%e6%96%99%e8%99%95%e7%90%86/feed/</wfw:commentRss>
			<slash:comments>0</slash:comments>
		
		
			</item>
		<item>
		<title>Logistic Regression 羅吉斯迴歸 &#124; part1 &#8211; 資料探勘與處理 &#124; 統計 R語言</title>
		<link>/logistic-regression-part1-%e7%be%85%e5%90%89%e6%96%af%e8%bf%b4%e6%ad%b8/</link>
					<comments>/logistic-regression-part1-%e7%be%85%e5%90%89%e6%96%af%e8%bf%b4%e6%ad%b8/#comments</comments>
		
		<dc:creator><![CDATA[jamleecute]]></dc:creator>
		<pubDate>Tue, 28 Aug 2018 06:24:19 +0000</pubDate>
				<category><![CDATA[ 程式與統計]]></category>
		<category><![CDATA[統計模型]]></category>
		<category><![CDATA[data pre processing]]></category>
		<category><![CDATA[eda]]></category>
		<category><![CDATA[exploratory data analysis]]></category>
		<category><![CDATA[glm]]></category>
		<category><![CDATA[information value]]></category>
		<category><![CDATA[IV]]></category>
		<category><![CDATA[logistic regression]]></category>
		<category><![CDATA[羅吉斯回歸]]></category>
		<category><![CDATA[資料探索]]></category>
		<category><![CDATA[資料預處理]]></category>
		<guid isPermaLink="false">/?p=846</guid>

					<description><![CDATA[<p>Logistic Regression, 羅吉斯回歸模型，適用於預測二元類別目標變數的發生機率(p)，和線性回歸模型類似，與線性回歸主要不同之處在於：(1) 目 [&#8230;]</p>
<p>這篇文章 <a rel="nofollow" href="/logistic-regression-part1-%e7%be%85%e5%90%89%e6%96%af%e8%bf%b4%e6%ad%b8/">Logistic Regression 羅吉斯迴歸 | part1 &#8211; 資料探勘與處理 | 統計 R語言</a> 最早出現於 <a rel="nofollow" href="/">果醬珍珍•JamJam</a>。</p>
]]></description>
										<content:encoded><![CDATA[<p class=""></p>
<p>Logistic Regression, 羅吉斯回歸模型，適用於<span style="color: #9f6ad4;">預測<span style="text-decoration: underline;">二元類別目標變數</span>的發生機率(p)</span>，和線性回歸模型類似，與線性回歸主要不同之處在於：(1) 目標變數是目標事件發生機率P經過log函數轉換成log odds值才進行線性預測，且(2)羅吉斯回歸的各項參數是透過最大概似法(MLE)進行估計的。</p>
<h3>Logistic Regression 羅吉斯回歸模型簡介</h3>
<p>線性迴歸模型是用來預測連續型變數，而羅吉斯回歸則是用來預測類別型變數。<br />
羅吉斯回歸和線性回歸模型類似，只不過<span style="color: #9d6ad4;">預測類別目標變數是經過log函數轉換才投入線性模型中的</span>。羅吉斯回歸方程式<span style="color: #9d6ad4;">將類別目標變數轉換為事件的log odds值，也就是\(\log\lgroup\frac{P_{i}}{1-P_{i}}\rgroup\)</span>，來預測Z與預測變數間(X1~Xn)的線性關係。</p>
<p><strong>羅吉斯回歸方程式：</strong></p>
<p><span id="MathJax-Span-15" class="mrow"><span id="MathJax-Span-43" class="mo">$$Z_{i}=\log\lgroup\frac{P_{i}}{1-P_{i}}\rgroup=\beta_{0}+\beta_{1}*x_{1}+&#8230;+\beta_{n}*x_{n}$$</span></span></p>
<p>其中：</p>
<p>(1) \(P_{i}\)為事件發生的機率值。</p>
<p>(2) \(\lgroup\frac{P_{i}}{1-P_{i}}\rgroup\)為勝算比(Odds Ratio)。</p>
<p>在R語言中，上述模型可透過<span style="color: #9d6ad4;">glm()函式</span>，將參數設定為<span style="color: #0000ff;"><span style="color: #9d6ad4;">family=&#8221;binomial&#8221;</span><span style="color: #000000;">來執行</span></span>。</p>
<p>但因為我們真正關心的是模型預測的事件發生機率值Pi。所以，預測結果則透過plogis()函數將事件的log odds轉換為Pi。轉換公式如下：</p>
<p>$$P_{i}=1-\lgroup\frac{1}{1+e_{i}^z}\rgroup$$</p>
<p>羅吉斯回歸透過log函數轉換，產生了一個臨界遞增的S型函數，<span style="color: #9d6ad4;">適用於分析機率模型</span>。<br />
而不同於線性迴歸，羅吉斯回歸分析的各項參數係數，是透過最大概似法(MLE)進行估計。</p>
<h3>分析資料與問題</h3>
<p>Problem: 預測薪資大於50K(ABOVE50K)的影響特徵因素有哪些？</p>
<p>Data: <a href="https://archive.ics.uci.edu/ml/datasets/adult">adult dataset</a> (snapshot)</p>
<p>目標變數(1)：ABOVE50K</p>
<p>預測變數(13)：AGE, WORKCLASS, EDUCATION, EDUCATIONNUM, MARITALSTATUS, OCCUPATION, RELATIONSHIP, RACE, SEX, CAPITALGAIN, CAPITALLOSS, HOURSPERWEEK, NATIVECOUNTRY</p>
<h3>分析步驟</h3>
<p>(part 1 篇會說明步驟1~5的部分)</p>
<ol>
<li><span style="color: #9d6ad4;">資料載入與檢視</span></li>
<li><span style="color: #9d6ad4;">資料探勘</span></li>
<li><span style="color: #9d6ad4;">資料前處理</span></li>
<li><span style="color: #9d6ad4;">產生訓練資料集與測試資料集</span></li>
<li><span style="color: #9d6ad4;">計算特徵變數IV值(Information Value)，篩選變數</span></li>
<li>訓練模型與預測</li>
<li>模型診斷與調整</li>
<li> 模型比較(v.s. Machine Learning Methods)</li>
</ol>
<div align="center"><script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><br />
<!-- text & display ads 1 --><br />
<ins class="adsbygoogle" style="display: block;" data-ad-client="ca-pub-7946632597933771" data-ad-slot="8154450369" data-ad-format="auto" data-full-width-responsive="true"></ins><br />
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script></div>
<h3>1. 資料載入與檢視</h3>
<p></p><pre class="crayon-plain-tag"># download from google drive's shareable link:
# https://drive.google.com/file/d/1L71tumU33xmVa2EtxjTyrZ2F6CaXn9iR/view?usp=sharing
id &lt;- "1L71tumU33xmVa2EtxjTyrZ2F6CaXn9iR" # google file ID
inputData &lt;- read.csv(sprintf("https://docs.google.com/uc?id=%s&amp;export=download", id))
# 摘要資料集
summary(inputData)

# AGE                    WORKCLASS         FNLWGT                EDUCATION    
# Min.   :17.00    Private         :22696   Min.   :  12285    HS-grad     :10501  
# 1st Qu.:28.00    Self-emp-not-inc: 2541   1st Qu.: 117827    Some-college: 7291  
# Median :37.00    Local-gov       : 2093   Median : 178356    Bachelors   : 5355  
# Mean   :38.58    ?               : 1836   Mean   : 189778    Masters     : 1723  
# 3rd Qu.:48.00    State-gov       : 1298   3rd Qu.: 237051    Assoc-voc   : 1382  
# Max.   :90.00    Self-emp-inc    : 1116   Max.   :1484705    11th        : 1175  
#                 (Other)          :  981                     (Other)      : 5134  
# EDUCATIONNUM                  MARITALSTATUS              OCCUPATION  
# Min.   : 1.00    Divorced             : 4443    Prof-specialty :4140  
# 1st Qu.: 9.00    Married-AF-spouse    :   23    Craft-repair   :4099  
# Median :10.00    Married-civ-spouse   :14976    Exec-managerial:4066  
# Mean   :10.08    Married-spouse-absent:  418    Adm-clerical   :3770  
# 3rd Qu.:12.00    Never-married        :10683    Sales          :3650  
# Max.   :16.00    Separated            : 1025    Other-service  :3295  
#                  Widowed              :  993   (Other)         :9541  
# RELATIONSHIP                    RACE            SEX       
# Husband       :13193    Amer-Indian-Eskimo:  311    Female:10771  
# Not-in-family : 8305    Asian-Pac-Islander: 1039    Male  :21790  
# Other-relative:  981    Black             : 3124                  
# Own-child     : 5068    Other             :  271                  
# Unmarried     : 3446    White             :27816                  
# Wife          : 1568                                              
# 
# CAPITALGAIN     CAPITALLOSS      HOURSPERWEEK          NATIVECOUNTRY  
# Min.   :    0   Min.   :   0.0   Min.   : 1.00    United-States:29170  
# 1st Qu.:    0   1st Qu.:   0.0   1st Qu.:40.00    Mexico       :  643  
# Median :    0   Median :   0.0   Median :40.00    ?            :  583  
# Mean   : 1078   Mean   :  87.3   Mean   :40.44    Philippines  :  198  
# 3rd Qu.:    0   3rd Qu.:   0.0   3rd Qu.:45.00    Germany      :  137  
# Max.   :99999   Max.   :4356.0   Max.   :99.00    Canada       :  121  
#                                                  (Other)       : 1709  
# ABOVE50K     
# Min.   :0.0000  
# 1st Qu.:0.0000  
# Median :0.0000  
# Mean   :0.2408  
# 3rd Qu.:0.0000  
# Max.   :1.0000</pre><p>由於我們的目標變數目前是數值0,1，為了後續分析，我們決定(1)ABOVE50K轉變成(&lt;=50K, &gt;50K)的factor變數，並(2)另外新增ABOVE50K_y(0,1)的factor變數。</p><pre class="crayon-plain-tag"># 將ABOVE50K原始0,1轉換成&lt;=50K, &gt; 50K的factor資料類型
inputData$ABOVE50K &lt;- factor(x = inputData$ABOVE50K, levels = c(0,1), labels = c('&lt;=50K', '&gt;50K'))
# 產生新factor變數ABOVE50K_y：
library(dplyr)
inputData$ABOVE50K_y &lt;- as.factor(case_when(inputData$ABOVE50K == "&lt;=50K" ~ 0,
                                             inputData$ABOVE50K == "&gt;50K" ~ 1))
# 確認轉換後的變數沒有問題
summary(inputData$ABOVE50K)
# &lt;=50K  &gt;50K 
# 24720  7841 
summary(inputData$ABOVE50K_y)
# 0     1 
# 24720  7841</pre><p>最後再確認一次資料集所有變數型態。</p><pre class="crayon-plain-tag"># 查看資料結構:資料變數、型態
str(inputData)

# 'data.frame':	32561 obs. of  16 variables:
# $ AGE          : int  39 50 38 53 28 37 49 52 31 42 ...
# $ WORKCLASS    : Factor w/ 9 levels " ?"," Federal-gov",..: 8 7 5 5 5 5 5 7 5 5 ...
# $ FNLWGT       : int  77516 83311 215646 234721 338409 284582 160187 209642 45781 159449 ...
# $ EDUCATION    : Factor w/ 16 levels " 10th"," 11th",..: 10 10 12 2 10 13 7 12 13 10 ...
# $ EDUCATIONNUM : int  13 13 9 7 13 14 5 9 14 13 ...
# $ MARITALSTATUS: Factor w/ 7 levels " Divorced"," Married-AF-spouse",..: 5 3 1 3 3 3 4 3 5 3 ...
# $ OCCUPATION   : Factor w/ 15 levels " ?"," Adm-clerical",..: 2 5 7 7 11 5 9 5 11 5 ...
# $ RELATIONSHIP : Factor w/ 6 levels " Husband"," Not-in-family",..: 2 1 2 1 6 6 2 1 2 1 ...
# $ RACE         : Factor w/ 5 levels " Amer-Indian-Eskimo",..: 5 5 5 3 3 5 3 5 5 5 ...
# $ SEX          : Factor w/ 2 levels " Female"," Male": 2 2 2 2 1 1 1 2 1 2 ...
# $ CAPITALGAIN  : int  2174 0 0 0 0 0 0 0 14084 5178 ...
# $ CAPITALLOSS  : int  0 0 0 0 0 0 0 0 0 0 ...
# $ HOURSPERWEEK : int  40 13 40 40 40 40 16 45 50 40 ...
# $ NATIVECOUNTRY: Factor w/ 42 levels " ?"," Cambodia",..: 40 40 40 40 6 40 24 40 40 40 ...
# $ ABOVE50K     : Factor w/ 2 levels "&lt;=50K","&gt;50K": 1 1 1 1 1 1 1 2 2 2 ...
# $ ABOVE50K_y   : Factor w/ 2 levels "0","1": 1 1 1 1 1 1 1 2 2 2 ...</pre><p>幾個光看變數名稱不足以了解的變數說明如下：<br />
(1) fnlwgt : 代表final weight，即該代表個體在母體所佔比例<br />
(2) educatoin_num：代表受教育的時間(年份)<br />
<span style="color: #9d6ad4;">為了簡化分析，我們將忽略fnlwgt每個代表個體在母體中所佔比重。</span></p>
<h3>2. 資料探勘(Exploratory Data Analysis)</h3>
<p></p><pre class="crayon-plain-tag"># 載入繪圖所需套件
library(ggplot2)
library(scales) # needed for labels=percent</pre><p>2-1. Age</p>
<p>查看年齡變數(AGE)各區間次數分佈與每區間薪資水準組成比例。</p><pre class="crayon-plain-tag"># 2-1. age
summary(inputData$AGE)
# Min. 1st Qu.  Median    Mean 3rd Qu.    Max. 
# 17.00   28.00   37.00   38.58   48.00   90.00 

gg &lt;- 
  ggplot(data = inputData, aes(x = as.numeric(AGE))) +
  geom_histogram(color = "black",binwidth = 1, aes(group=ABOVE50K, fill = ABOVE50K)) +
  geom_vline(xintercept = mean(inputData$AGE[inputData$ABOVE50K == 1]), col = "blue", lty = 5, lwd = 0.8) +
  geom_vline(xintercept = mean(inputData$AGE[inputData$ABOVE50K == 0]), col = "black", lty = 5, lwd = 0.8)
gg</pre><p>可以發現薪資水平高於50K的年齡偏高，平均數約落在40-50歲，而薪資水平小於等於50K的族群偏年輕。</p>
<p><img loading="lazy" class="alignnone size-large wp-image-890" src="/wp-content/uploads/2018/08/pic01-1024x659.png" alt="logistic regression" width="960" height="618" srcset="/wp-content/uploads/2018/08/pic01-1024x659.png 1024w, /wp-content/uploads/2018/08/pic01-300x193.png 300w, /wp-content/uploads/2018/08/pic01-768x494.png 768w, /wp-content/uploads/2018/08/pic01-1140x734.png 1140w" sizes="(max-width: 960px) 100vw, 960px" /></p>
<p>2-2. Workclass</p><pre class="crayon-plain-tag">summary(inputData$WORKCLASS)
# ?       Federal-gov         Local-gov      Never-worked 
# 1836               960              2093                 7 
# Private      Self-emp-inc  Self-emp-not-inc         State-gov 
# 22696              1116              2541              1298 
# Without-pay 
# 14</pre><p>查看workclass各類別次數分佈。</p><pre class="crayon-plain-tag">inputData$WORKCLASS &lt;- factor(x = inputData$WORKCLASS,levels = names(sort(table(inputData$WORKCLASS),decreasing = TRUE)))
ggplot(data = inputData, aes(x = WORKCLASS, fill = ABOVE50K)) +
  geom_bar() +
  geom_text(stat = "count", aes(label=..count..),size=3.5,position = position_stack(vjust = 0.5)) +
  scale_fill_brewer(palette="Paired")</pre><p><img loading="lazy" class="alignnone size-large wp-image-891" src="/wp-content/uploads/2018/08/pic02-1024x659.png" alt="logistic regression" width="960" height="618" srcset="/wp-content/uploads/2018/08/pic02-1024x659.png 1024w, /wp-content/uploads/2018/08/pic02-300x193.png 300w, /wp-content/uploads/2018/08/pic02-768x494.png 768w, /wp-content/uploads/2018/08/pic02-1140x734.png 1140w" sizes="(max-width: 960px) 100vw, 960px" /></p>
<p>查看workclass各類別薪資水準組成比例。</p><pre class="crayon-plain-tag"># 首先，先計算類別變數中，不同類別水準值中的薪資水平分佈比例
df2 &lt;- cbind.data.frame(WORKCLASS = inputData$WORKCLASS,ABOVE50K = inputData$ABOVE50K)
df2.summary &lt;- 
  df2 %&gt;% group_by(WORKCLASS,ABOVE50K) %&gt;% 
  summarise(n = n()) %&gt;% 
  mutate(ratio=scales::percent(n/sum(n)))

# 依據ABOVE50K的比例排序，更可以看出哪些類別水準有較高ABOVE50K比例
ggplot(inputData, aes(x = forcats::fct_reorder(f = WORKCLASS, x = as.numeric(ABOVE50K),fun = mean, .desc = TRUE), fill = ABOVE50K)) +
  geom_bar(position = "fill") + 
  geom_text(data=df2.summary, aes(y=n,label=ratio),
            position=position_fill(vjust=0.5)) +
  scale_y_continuous(labels = scales::percent) +
  scale_fill_brewer(palette="Paired")</pre><p><img loading="lazy" class="alignnone size-large wp-image-957" src="/wp-content/uploads/2018/08/pic03-1024x928.png" alt="logistic regression" width="960" height="870" srcset="/wp-content/uploads/2018/08/pic03-1024x928.png 1024w, /wp-content/uploads/2018/08/pic03-300x272.png 300w, /wp-content/uploads/2018/08/pic03-768x696.png 768w, /wp-content/uploads/2018/08/pic03-1140x1034.png 1140w" sizes="(max-width: 960px) 100vw, 960px" /></p>
<div align="center"><script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><br />
<!-- text & display ads 1 --><br />
<ins class="adsbygoogle" style="display: block;" data-ad-client="ca-pub-7946632597933771" data-ad-slot="8154450369" data-ad-format="auto" data-full-width-responsive="true"></ins><br />
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script></div>
<p>2-3. Education</p>
<p>基礎敘述統計</p><pre class="crayon-plain-tag">summary(inputData$EDUCATION)
# 10th          11th          12th       1st-4th       5th-6th       7th-8th 
# 933          1175           433           168           333           646 
# 9th    Assoc-acdm     Assoc-voc     Bachelors     Doctorate       HS-grad 
# 514          1067          1382          5355           413         10501 
# Masters     Preschool   Prof-school  Some-college 
# 1723            51           576          7291</pre><p>次數分配圖</p><pre class="crayon-plain-tag">inputData$EDUCATION &lt;- factor(x = inputData$EDUCATION,levels = names(sort(table(inputData$EDUCATION),decreasing = TRUE)))
ggplot(data = inputData, aes(x = EDUCATION, fill = ABOVE50K)) +
  geom_bar() +
  geom_text(stat = "count", aes(label=..count..),size=3.5,position = position_stack(vjust = 0.5)) +
  scale_fill_brewer(palette="Paired") +
  theme(axis.text.x = element_text(angle = 30, hjust = 1))</pre><p><img loading="lazy" class="alignnone size-large wp-image-893" src="/wp-content/uploads/2018/08/pic04-1024x659.png" alt="logistic regression" width="960" height="618" srcset="/wp-content/uploads/2018/08/pic04-1024x659.png 1024w, /wp-content/uploads/2018/08/pic04-300x193.png 300w, /wp-content/uploads/2018/08/pic04-768x494.png 768w, /wp-content/uploads/2018/08/pic04-1140x734.png 1140w" sizes="(max-width: 960px) 100vw, 960px" /></p>
<p>各類別水準值中目標變數分佈圖</p><pre class="crayon-plain-tag"># 首先，先計算類別變數中，不同類別水準值中的薪資水平分佈比例
df2 &lt;- cbind.data.frame(EDUCATION = inputData$EDUCATION,ABOVE50K = inputData$ABOVE50K)
df2.summary &lt;- 
  df2 %&gt;% group_by(EDUCATION) %&gt;% 
  count(ABOVE50K) %&gt;% 
  mutate(ratio=scales::percent(n/sum(n))) %&gt;% 
  ungroup()

# 依據ABOVE50K的比例排序，更可以看出哪些類別水準有較高ABOVE50K比例
ggplot(inputData, aes(x = forcats::fct_reorder(f = EDUCATION, x = as.numeric(ABOVE50K), fun = mean, .desc = TRUE), fill = ABOVE50K)) +
  geom_bar(position = "fill") + 
  geom_text(data=df2.summary, aes(y=n,label=ratio),
            position=position_fill(vjust=0.5)) +
  scale_y_continuous(labels = scales::percent) +
  scale_fill_brewer(palette="Paired") +
  theme(axis.text.x = element_text(angle = 30, hjust = 1))</pre><p><img loading="lazy" class="alignnone size-large wp-image-960" src="/wp-content/uploads/2018/08/pic05-1024x928.png" alt="logistic regression" width="960" height="870" srcset="/wp-content/uploads/2018/08/pic05-1024x928.png 1024w, /wp-content/uploads/2018/08/pic05-300x272.png 300w, /wp-content/uploads/2018/08/pic05-768x696.png 768w, /wp-content/uploads/2018/08/pic05-1140x1034.png 1140w" sizes="(max-width: 960px) 100vw, 960px" /></p>
<p>2-4. Educationnum (教育年份)</p>
<p>基礎敘述統計</p><pre class="crayon-plain-tag">summary(inputData$AGE)
# Min. 1st Qu.  Median    Mean 3rd Qu.    Max. 
# 17.00   28.00   37.00   38.58   48.00   90.00</pre><p>次數分配圖</p><pre class="crayon-plain-tag">inputData$AGE_cut &lt;- inputData$AGE 
inputData$AGE_cut &lt;- cut(inputData$AGE_cut, breaks = seq(15,90,5),include.lowest = TRUE)
ggplot(data = inputData, aes(x = AGE_cut, fill = ABOVE50K)) +
  geom_bar() +
  geom_text(stat = "count", aes(label=..count..),size=3.5,position = position_stack(vjust = 0.5)) +
  scale_fill_brewer(palette="Paired") +
  labs(x = "AGE")</pre><p><img loading="lazy" class="alignnone size-large wp-image-895" src="/wp-content/uploads/2018/08/pic06-1024x659.png" alt="logistic regression" width="960" height="618" srcset="/wp-content/uploads/2018/08/pic06-1024x659.png 1024w, /wp-content/uploads/2018/08/pic06-300x193.png 300w, /wp-content/uploads/2018/08/pic06-768x494.png 768w, /wp-content/uploads/2018/08/pic06-1140x734.png 1140w" sizes="(max-width: 960px) 100vw, 960px" /></p>
<p>各類別水準值中目標變數分佈圖</p><pre class="crayon-plain-tag"># 首先，先計算類別變數中，不同類別水準值中的薪資水平分佈比例
df2 &lt;- cbind.data.frame(AGE_cut = inputData$AGE_cut,ABOVE50K = inputData$ABOVE50K)
df2.summary &lt;- 
  df2 %&gt;% group_by(AGE_cut) %&gt;% 
  count(ABOVE50K) %&gt;% 
  mutate(ratio=scales::percent(n/sum(n))) %&gt;% 
  ungroup()

# 依據ABOVE50K的比例排序，更可以看出哪些類別水準有較高ABOVE50K比例
ggplot(inputData, aes(x = forcats::fct_reorder(f = AGE_cut, x = as.numeric(ABOVE50K), fun = mean, .desc = TRUE), fill = ABOVE50K)) +
  geom_bar(position = "fill") + 
  geom_text(data=df2.summary, aes(y=n,label=ratio),
            position=position_fill(vjust=0.5)) +
  scale_y_continuous(labels = scales::percent) +
  scale_fill_brewer(palette="Paired") +
  labs(x = "AGE")</pre><p><img loading="lazy" class="alignnone size-large wp-image-896" src="/wp-content/uploads/2018/08/pic07-1024x659.png" alt="logistic regression" width="960" height="618" srcset="/wp-content/uploads/2018/08/pic07-1024x659.png 1024w, /wp-content/uploads/2018/08/pic07-300x193.png 300w, /wp-content/uploads/2018/08/pic07-768x494.png 768w, /wp-content/uploads/2018/08/pic07-1140x734.png 1140w" sizes="(max-width: 960px) 100vw, 960px" /></p>
<p>2-5. MaritalStatus</p>
<p>基礎敘述統計</p><pre class="crayon-plain-tag">summary(inputData$MARITALSTATUS)
# Divorced      Married-AF-spouse     Married-civ-spouse 
# 4443                     23                  14976 
# Married-spouse-absent          Never-married              Separated 
# 418                  10683                   1025 
# Widowed 
# 993</pre><p>次數分配圖</p><pre class="crayon-plain-tag">inputData$MARITALSTATUS &lt;- factor(x = inputData$MARITALSTATUS,levels = names(sort(table(inputData$MARITALSTATUS),decreasing = TRUE)))
ggplot(data = inputData, aes(x = MARITALSTATUS, fill = ABOVE50K)) +
  geom_bar() +
  geom_text(stat = "count", aes(label=..count..),size=3.5,position = position_stack(vjust = 0.5)) +
  scale_fill_brewer(palette="Paired") +
  theme(axis.text.x = element_text(angle = 30, hjust = 1))</pre><p><img loading="lazy" class="alignnone size-large wp-image-897" src="/wp-content/uploads/2018/08/pic08-1024x659.png" alt="logistic regression" width="960" height="618" srcset="/wp-content/uploads/2018/08/pic08-1024x659.png 1024w, /wp-content/uploads/2018/08/pic08-300x193.png 300w, /wp-content/uploads/2018/08/pic08-768x494.png 768w, /wp-content/uploads/2018/08/pic08-1140x734.png 1140w" sizes="(max-width: 960px) 100vw, 960px" /></p>
<p>各類別水準值中目標變數分佈圖</p><pre class="crayon-plain-tag"># 首先，先計算類別變數中，不同類別水準值中的薪資水平分佈比例
df2 &lt;- cbind.data.frame(MARITALSTATUS = inputData$MARITALSTATUS,ABOVE50K = inputData$ABOVE50K)
df2.summary &lt;- 
  df2 %&gt;% group_by(MARITALSTATUS) %&gt;% 
  count(ABOVE50K) %&gt;% 
  mutate(ratio=scales::percent(n/sum(n))) %&gt;% 
  ungroup()

# 依據ABOVE50K的比例排序，更可以看出哪些類別水準有較高ABOVE50K比例
ggplot(inputData, aes(x = forcats::fct_reorder(f = MARITALSTATUS, x = as.numeric(ABOVE50K), fun = mean, .desc = TRUE), fill = ABOVE50K)) +
  geom_bar(position = "fill") + 
  geom_text(data=df2.summary, aes(y=n,label=ratio),
            position=position_fill(vjust=0.5)) +
  scale_y_continuous(labels = scales::percent) +
  scale_fill_brewer(palette="Paired") +
  labs(x = "MARITALSTATUS", y = "percentage") +
  theme(axis.text.x = element_text(angle = 30, hjust = 1))</pre><p><img loading="lazy" class="alignnone size-large wp-image-898" src="/wp-content/uploads/2018/08/pic09-1024x659.png" alt="logistic regression" width="960" height="618" srcset="/wp-content/uploads/2018/08/pic09-1024x659.png 1024w, /wp-content/uploads/2018/08/pic09-300x193.png 300w, /wp-content/uploads/2018/08/pic09-768x494.png 768w, /wp-content/uploads/2018/08/pic09-1140x734.png 1140w" sizes="(max-width: 960px) 100vw, 960px" /></p>
<p>如果想要同一張圖y軸可以看到frequency，stacked bar可以看到目標類別水平的比例分佈，可以使用下面方法繪製。</p><pre class="crayon-plain-tag"># 如果想要在同一張圖同時看到frequencies &amp; proportion:
# 先新增一欄label位置的欄位
# (依照ABOVE50K的類別水準順序，計算累積數值，並將數值置中於各類別累積高度)
df3.summary &lt;-
  df2.summary %&gt;%
  group_by(MARITALSTATUS) %&gt;%
  #因為繪圖資訊是先畫&gt;50K，再畫&lt;=50K，故要調整累積數值計算的順序
  do( data.frame(with(data=., .[order(desc(ABOVE50K)),] )) ) %&gt;% 
  ungroup() %&gt;% 
  group_by(MARITALSTATUS) %&gt;%
  mutate(pos = (cumsum(n) - (0.5 * n))) %&gt;%
  as.data.frame() %&gt;% 
  ungroup()

ggplot(data = df3.summary,mapping = aes(x = MARITALSTATUS, y = n, fill = ABOVE50K)) +
  geom_bar(stat = "identity") + 
  geom_text(mapping = aes(y = pos, label = ratio), size = 3) +
  scale_fill_brewer(palette="Paired") +
  labs(title = "MARITALSTATUS VS ABOVE50K",
       x = "MARITALSTATUS", y = "Frequencies") + # Add Title and Labels
  theme(plot.title = element_text(hjust = 0.5)) # Change the appearance of the main title</pre><p><img loading="lazy" class="alignnone size-large wp-image-958" src="/wp-content/uploads/2018/08/pic10-1024x928.png" alt="logistic regression" width="960" height="870" srcset="/wp-content/uploads/2018/08/pic10-1024x928.png 1024w, /wp-content/uploads/2018/08/pic10-300x272.png 300w, /wp-content/uploads/2018/08/pic10-768x696.png 768w, /wp-content/uploads/2018/08/pic10-1140x1034.png 1140w" sizes="(max-width: 960px) 100vw, 960px" /></p>
<p>2-6. Occupation職業</p>
<p>基礎敘述統計</p><pre class="crayon-plain-tag">summary(inputData$OCCUPATION)
# ?       Adm-clerical       Armed-Forces       Craft-repair 
# 1843               3770                  9               4099 
# Exec-managerial    Farming-fishing  Handlers-cleaners  Machine-op-inspct 
# 4066                994               1370               2002 
# Other-service    Priv-house-serv     Prof-specialty    Protective-serv 
# 3295                149               4140                649 
# Sales       Tech-support   Transport-moving 
# 3650                928               1597</pre><p>可以發現類別水準值滿複雜的。</p>
<p>次數分配圖</p><pre class="crayon-plain-tag">inputData$OCCUPATION &lt;- factor(x = inputData$OCCUPATION,levels = names(sort(table(inputData$OCCUPATION),decreasing = TRUE)))
ggplot(data = inputData, aes(x = OCCUPATION, fill = ABOVE50K)) +
  geom_bar() +
  geom_text(stat = "count", aes(label=..count..),size=3.5,position = position_stack(vjust = 0.5)) +
  scale_fill_brewer(palette="Paired") +
  theme(axis.text.x = element_text(angle = 30, hjust = 1))</pre><p><img loading="lazy" class="alignnone size-large wp-image-900" src="/wp-content/uploads/2018/08/pic11-1024x659.png" alt="logistic regression" width="960" height="618" srcset="/wp-content/uploads/2018/08/pic11-1024x659.png 1024w, /wp-content/uploads/2018/08/pic11-300x193.png 300w, /wp-content/uploads/2018/08/pic11-768x494.png 768w, /wp-content/uploads/2018/08/pic11-1140x734.png 1140w" sizes="(max-width: 960px) 100vw, 960px" /></p>
<p>各類別水準值中目標變數分佈圖</p><pre class="crayon-plain-tag"># 首先，先計算類別變數中，不同類別水準值中的薪資水平分佈比例
df2 &lt;- cbind.data.frame(OCCUPATION = inputData$OCCUPATION,ABOVE50K = inputData$ABOVE50K)
df2.summary &lt;- 
  df2 %&gt;% group_by(OCCUPATION) %&gt;% 
  count(ABOVE50K) %&gt;% 
  mutate(ratio=scales::percent(n/sum(n))) %&gt;% 
  as.data.frame() %&gt;% 
  ungroup()

# 依據ABOVE50K的比例排序，更可以看出哪些類別水準有較高ABOVE50K比例
ggplot(inputData, aes(x = forcats::fct_reorder(f = OCCUPATION, x = as.numeric(ABOVE50K), fun = mean, .desc = TRUE), fill = ABOVE50K)) +
  geom_bar(position = "fill") + 
  geom_text(data=df2.summary, aes(y=n,label=ratio),
            position=position_fill(vjust=0.5)) +
  scale_y_continuous(labels = scales::percent) +
  scale_fill_brewer(palette="Paired") +
  labs(x = "OCCUPATION", y = "percentage") +
  theme(axis.text.x = element_text(angle = 30, hjust = 1))</pre><p><img loading="lazy" class="alignnone size-large wp-image-901" src="/wp-content/uploads/2018/08/pic12-1024x659.png" alt="logistic regression" width="960" height="618" srcset="/wp-content/uploads/2018/08/pic12-1024x659.png 1024w, /wp-content/uploads/2018/08/pic12-300x193.png 300w, /wp-content/uploads/2018/08/pic12-768x494.png 768w, /wp-content/uploads/2018/08/pic12-1140x734.png 1140w" sizes="(max-width: 960px) 100vw, 960px" /></p>
<p>如果想要同一張圖y軸可以看到frequency，stacked bar可以看到目標類別水平的比例分佈，可以使用下面方法繪製。</p><pre class="crayon-plain-tag">df3.summary &lt;-
  df2.summary %&gt;%
  group_by(OCCUPATION) %&gt;%
  #因為繪圖資訊是先畫&gt;50K，再畫&lt;=50K，故要調整累積數值計算的順序
  do( data.frame(with(data=., .[order(desc(ABOVE50K)),] )) ) %&gt;% 
  ungroup() %&gt;% 
  group_by(OCCUPATION) %&gt;%
  mutate(pos = (cumsum(n) - (0.5 * n))) %&gt;%
  as.data.frame() %&gt;% 
  ungroup()

ggplot(data = df3.summary,mapping = aes(x = OCCUPATION, y = n, fill = ABOVE50K)) +
  geom_bar(stat = "identity") + 
  geom_text(mapping = aes(y = pos, label = ratio), size = 3) +
  scale_fill_brewer(palette="Paired") +
  labs(title = "OCCUPATION VS ABOVE50K",
       x = "OCCUPATION", y = "Frequencies") + # Add Title and Labels
  theme(plot.title = element_text(hjust = 0.5),
        axis.text.x = element_text(angle = 30, hjust = 1))</pre><p><img loading="lazy" class="alignnone size-large wp-image-902" src="/wp-content/uploads/2018/08/pic13-1024x659.png" alt="logistic regression" width="960" height="618" srcset="/wp-content/uploads/2018/08/pic13-1024x659.png 1024w, /wp-content/uploads/2018/08/pic13-300x193.png 300w, /wp-content/uploads/2018/08/pic13-768x494.png 768w, /wp-content/uploads/2018/08/pic13-1140x734.png 1140w" sizes="(max-width: 960px) 100vw, 960px" /></p>
<p>2-7. Relationship</p>
<p>基礎敘述統計</p><pre class="crayon-plain-tag">summary(inputData$RELATIONSHIP)
# Husband   Not-in-family  Other-relative       Own-child       Unmarried 
# 13193            8305             981            5068            3446 
# Wife 
# 1568</pre><p>次數分配圖</p><pre class="crayon-plain-tag">inputData$RELATIONSHIP &lt;- factor(x = inputData$RELATIONSHIP,levels = names(sort(table(inputData$RELATIONSHIP),decreasing = TRUE)))
ggplot(data = inputData, aes(x = RELATIONSHIP, fill = ABOVE50K)) +
  geom_bar() +
  geom_text(stat = "count", aes(label=..count..),size=3.5,position = position_stack(vjust = 0.5)) +
  scale_fill_brewer(palette="Paired")</pre><p><img loading="lazy" class="alignnone size-large wp-image-903" src="/wp-content/uploads/2018/08/pic14-1024x659.png" alt="logistic regression" width="960" height="618" srcset="/wp-content/uploads/2018/08/pic14-1024x659.png 1024w, /wp-content/uploads/2018/08/pic14-300x193.png 300w, /wp-content/uploads/2018/08/pic14-768x494.png 768w, /wp-content/uploads/2018/08/pic14-1140x734.png 1140w" sizes="(max-width: 960px) 100vw, 960px" /></p>
<p>各類別水準值中目標變數分佈圖</p><pre class="crayon-plain-tag"># 首先，先計算類別變數中，不同類別水準值中的薪資水平分佈比例
df2 &lt;- cbind.data.frame(RELATIONSHIP = inputData$RELATIONSHIP,ABOVE50K = inputData$ABOVE50K)
df2.summary &lt;- 
  df2 %&gt;% group_by(RELATIONSHIP) %&gt;% 
  count(ABOVE50K) %&gt;% 
  mutate(ratio=scales::percent(n/sum(n))) %&gt;% 
  as.data.frame() %&gt;% 
  ungroup()

# 依據ABOVE50K的比例排序，更可以看出哪些類別水準有較高ABOVE50K比例
ggplot(inputData, aes(x = forcats::fct_reorder(f = RELATIONSHIP, x = as.numeric(ABOVE50K), fun = mean, .desc = TRUE), fill = ABOVE50K)) +
  geom_bar(position = "fill") + 
  geom_text(data=df2.summary, aes(y=n,label=ratio),
            position=position_fill(vjust=0.5)) +
  scale_y_continuous(labels = scales::percent) +
  scale_fill_brewer(palette="Paired") +
  labs(x = "RELATIONSHIP", y = "percentage") +
  theme(axis.text.x = element_text(angle = 30, hjust = 1))</pre><p><img loading="lazy" class="alignnone size-large wp-image-904" src="/wp-content/uploads/2018/08/pic15-1024x659.png" alt="logistic regression" width="960" height="618" srcset="/wp-content/uploads/2018/08/pic15-1024x659.png 1024w, /wp-content/uploads/2018/08/pic15-300x193.png 300w, /wp-content/uploads/2018/08/pic15-768x494.png 768w, /wp-content/uploads/2018/08/pic15-1140x734.png 1140w" sizes="(max-width: 960px) 100vw, 960px" /></p>
<p>繪製同時一張圖呈現frequency與stacked bar目標類別水平的比例分佈圖。</p><pre class="crayon-plain-tag">df3.summary &lt;-
  df2.summary %&gt;%
  group_by(RELATIONSHIP) %&gt;%
  #因為繪圖資訊是先畫&gt;50K，再畫&lt;=50K，故要調整累積數值計算的順序
  do( data.frame(with(data=., .[order(desc(ABOVE50K)),] )) ) %&gt;% 
  ungroup() %&gt;% 
  group_by(RELATIONSHIP) %&gt;%
  mutate(pos = (cumsum(n) - (0.5 * n))) %&gt;%
  as.data.frame() %&gt;% 
  ungroup()

ggplot(data = df3.summary,mapping = aes(x = RELATIONSHIP, y = n, fill = ABOVE50K)) +
  geom_bar(stat = "identity") + 
  geom_text(mapping = aes(y = pos, label = ratio), size = 3) +
  scale_fill_brewer(palette="Paired") +
  labs(title = "RELATIONSHIP VS ABOVE50K",
       x = "RELATIONSHIP", y = "Frequencies") + # Add Title and Labels
  theme(plot.title = element_text(hjust = 0.5),
        axis.text.x = element_text(angle = 30, hjust = 1)) # Change the appearance of the main title</pre><p><img loading="lazy" class="alignnone size-large wp-image-905" src="/wp-content/uploads/2018/08/pic16-1024x659.png" alt="logistic regression" width="960" height="618" srcset="/wp-content/uploads/2018/08/pic16-1024x659.png 1024w, /wp-content/uploads/2018/08/pic16-300x193.png 300w, /wp-content/uploads/2018/08/pic16-768x494.png 768w, /wp-content/uploads/2018/08/pic16-1140x734.png 1140w" sizes="(max-width: 960px) 100vw, 960px" /></p>
<p>2-8. Race種族</p>
<p>基礎敘述統計</p><pre class="crayon-plain-tag">summary(inputData$RACE)
# Amer-Indian-Eskimo  Asian-Pac-Islander               Black               Other               White 
# 311                1039                3124                 271               27816</pre><p>次數分配圖</p><pre class="crayon-plain-tag">inputData$RACE &lt;- factor(x = inputData$RACE,levels = names(sort(table(inputData$RACE),decreasing = TRUE)))
ggplot(data = inputData, aes(x = RACE, fill = ABOVE50K)) +
  geom_bar() +
  geom_text(stat = "count", aes(label=..count..),size=3.5,position = position_stack(vjust = 0.5)) +
  scale_fill_brewer(palette="Paired") +
  theme(axis.text.x = element_text(angle = 30, hjust = 1))</pre><p><img loading="lazy" class="alignnone size-large wp-image-906" src="/wp-content/uploads/2018/08/pic17-1024x933.png" alt="logistic regression" width="960" height="875" srcset="/wp-content/uploads/2018/08/pic17-1024x933.png 1024w, /wp-content/uploads/2018/08/pic17-300x273.png 300w, /wp-content/uploads/2018/08/pic17-768x700.png 768w, /wp-content/uploads/2018/08/pic17-1140x1039.png 1140w" sizes="(max-width: 960px) 100vw, 960px" /></p>
<p>各類別水準值中目標變數分佈圖</p><pre class="crayon-plain-tag"># 首先，先計算類別變數中，不同類別水準值中的薪資水平分佈比例
df2 &lt;- cbind.data.frame(RACE = inputData$RACE,ABOVE50K = inputData$ABOVE50K)
df2.summary &lt;- 
  df2 %&gt;% group_by(RACE) %&gt;% 
  count(ABOVE50K) %&gt;% 
  mutate(ratio=scales::percent(n/sum(n))) %&gt;% 
  as.data.frame() %&gt;% 
  ungroup()

# 依據ABOVE50K的比例排序，更可以看出哪些類別水準有較高ABOVE50K比例
ggplot(inputData, aes(x = forcats::fct_reorder(f = RACE, x = as.numeric(ABOVE50K), fun = mean, .desc = TRUE), fill = ABOVE50K)) +
  geom_bar(position = "fill") + 
  geom_text(data=df2.summary, aes(y=n,label=ratio),
            position=position_fill(vjust=0.5)) +
  scale_y_continuous(labels = scales::percent) +
  scale_fill_brewer(palette="Paired") +
  labs(x = "RACE", y = "percentage") +
  theme(axis.text.x = element_text(angle = 30, hjust = 1))</pre><p><img loading="lazy" class="alignnone size-large wp-image-1581" src="/wp-content/uploads/2018/09/pic18-1-1024x928.png" alt="logistic regression" width="1024" height="928" srcset="/wp-content/uploads/2018/09/pic18-1-1024x928.png 1024w, /wp-content/uploads/2018/09/pic18-1-300x272.png 300w, /wp-content/uploads/2018/09/pic18-1-768x696.png 768w, /wp-content/uploads/2018/09/pic18-1-830x753.png 830w, /wp-content/uploads/2018/09/pic18-1-230x209.png 230w, /wp-content/uploads/2018/09/pic18-1-350x317.png 350w, /wp-content/uploads/2018/09/pic18-1-480x435.png 480w" sizes="(max-width: 1024px) 100vw, 1024px" /></p>
<p>繪製同時一張圖呈現frequency與stacked bar目標類別水平的比例分佈圖。</p><pre class="crayon-plain-tag">df3.summary &lt;-
  df2.summary %&gt;%
  group_by(RACE) %&gt;%
  #因為繪圖資訊是先畫&gt;50K，再畫&lt;=50K，故要調整累積數值計算的順序
  do( data.frame(with(data=., .[order(desc(ABOVE50K)),] )) ) %&gt;% 
  ungroup() %&gt;% 
  group_by(RACE) %&gt;%
  mutate(pos = (cumsum(n) - (0.5 * n))) %&gt;%
  as.data.frame() %&gt;% 
  ungroup()

ggplot(data = df3.summary,mapping = aes(x = RACE, y = n, fill = ABOVE50K)) +
  geom_bar(stat = "identity") + 
  geom_text(mapping = aes(y = pos, label = ratio), size = 3) +
  scale_fill_brewer(palette="Paired") +
  labs(title = "RACE VS ABOVE50K",
       x = "RACE", y = "Frequencies") + # Add Title and Labels
  theme(plot.title = element_text(hjust = 0.5),
        axis.text.x = element_text(angle = 30, hjust = 1)) # Change the appearance of the main title</pre><p><img loading="lazy" class="alignnone size-large wp-image-1572" src="/wp-content/uploads/2018/09/pic19-1024x602.png" alt="logistic regression" width="1024" height="602" srcset="/wp-content/uploads/2018/09/pic19-1024x602.png 1024w, /wp-content/uploads/2018/09/pic19-300x176.png 300w, /wp-content/uploads/2018/09/pic19-768x451.png 768w, /wp-content/uploads/2018/09/pic19-830x488.png 830w, /wp-content/uploads/2018/09/pic19-230x135.png 230w, /wp-content/uploads/2018/09/pic19-350x206.png 350w, /wp-content/uploads/2018/09/pic19-480x282.png 480w" sizes="(max-width: 1024px) 100vw, 1024px" /></p>
<p>2-9. Sex 性別</p>
<p>基礎敘述統計</p><pre class="crayon-plain-tag">summary(inputData$SEX)
# Female    Male 
# 10771   21790</pre><p>次數分配圖</p><pre class="crayon-plain-tag">inputData$SEX &lt;- factor(x = inputData$SEX,levels = names(sort(table(inputData$SEX),decreasing = TRUE)))
ggplot(data = inputData, aes(x = SEX, fill = ABOVE50K)) +
  geom_bar() +
  geom_text(stat = "count", aes(label=..count..),size=3.5,position = position_stack(vjust = 0.5)) +
  scale_fill_brewer(palette="Paired")</pre><p><img loading="lazy" class="alignnone size-large wp-image-1574" src="/wp-content/uploads/2018/09/pic20-1024x602.png" alt="logistic regression" width="1024" height="602" srcset="/wp-content/uploads/2018/09/pic20-1024x602.png 1024w, /wp-content/uploads/2018/09/pic20-300x176.png 300w, /wp-content/uploads/2018/09/pic20-768x451.png 768w, /wp-content/uploads/2018/09/pic20-830x488.png 830w, /wp-content/uploads/2018/09/pic20-230x135.png 230w, /wp-content/uploads/2018/09/pic20-350x206.png 350w, /wp-content/uploads/2018/09/pic20-480x282.png 480w" sizes="(max-width: 1024px) 100vw, 1024px" /></p>
<p>各類別水準值中目標變數分佈圖</p><pre class="crayon-plain-tag"># 首先，先計算類別變數中，不同類別水準值中的薪資水平分佈比例
df2 &lt;- cbind.data.frame(SEX = inputData$SEX,ABOVE50K = inputData$ABOVE50K)
df2.summary &lt;- 
  df2 %&gt;% group_by(SEX) %&gt;% 
  count(ABOVE50K) %&gt;% 
  mutate(ratio=scales::percent(n/sum(n))) %&gt;% 
  as.data.frame() %&gt;% 
  ungroup()

# 依據ABOVE50K的比例排序，更可以看出哪些類別水準有較高ABOVE50K比例
ggplot(inputData, aes(x = forcats::fct_reorder(f = SEX, x = as.numeric(ABOVE50K), fun = mean, .desc = TRUE), fill = ABOVE50K)) +
  geom_bar(position = "fill") + 
  geom_text(data=df2.summary, aes(y=n,label=ratio),
            position=position_fill(vjust=0.5)) +
  scale_y_continuous(labels = scales::percent) +
  scale_fill_brewer(palette="Paired") +
  labs(x = "SEX", y = "percentage") +
  theme(axis.text.x = element_text(angle = 30, hjust = 1))</pre><p><img loading="lazy" class="alignnone size-large wp-image-1575" src="/wp-content/uploads/2018/09/pic21-1024x602.png" alt="logistic regression" width="1024" height="602" srcset="/wp-content/uploads/2018/09/pic21-1024x602.png 1024w, /wp-content/uploads/2018/09/pic21-300x176.png 300w, /wp-content/uploads/2018/09/pic21-768x451.png 768w, /wp-content/uploads/2018/09/pic21-830x488.png 830w, /wp-content/uploads/2018/09/pic21-230x135.png 230w, /wp-content/uploads/2018/09/pic21-350x206.png 350w, /wp-content/uploads/2018/09/pic21-480x282.png 480w" sizes="(max-width: 1024px) 100vw, 1024px" /></p>
<p>繪製同時一張圖呈現frequency與stacked bar目標類別水平的比例分佈圖。</p><pre class="crayon-plain-tag">df3.summary &lt;-
  df2.summary %&gt;%
  group_by(SEX) %&gt;%
  #因為繪圖資訊是先畫&gt;50K，再畫&lt;=50K，故要調整累積數值計算的順序
  do( data.frame(with(data=., .[order(desc(ABOVE50K)),] )) ) %&gt;% 
  ungroup() %&gt;% 
  group_by(SEX) %&gt;%
  mutate(pos = (cumsum(n) - (0.5 * n))) %&gt;%
  as.data.frame() %&gt;% 
  ungroup()

ggplot(data = df3.summary,mapping = aes(x = SEX, y = n, fill = ABOVE50K)) +
  geom_bar(stat = "identity") + 
  geom_text(mapping = aes(y = pos, label = ratio), size = 3) +
  scale_fill_brewer(palette="Paired") +
  labs(title = "SEX VS ABOVE50K",
       x = "SEX", y = "Frequencies") + # Add Title and Labels
  theme(plot.title = element_text(hjust = 0.5),
        axis.text.x = element_text(angle = 30, hjust = 1)) # Change the appearance of the main title</pre><p>&nbsp;</p>
<p><img loading="lazy" class="alignnone size-large wp-image-1576" src="/wp-content/uploads/2018/09/pic22-1024x602.png" alt="logistic regression" width="1024" height="602" srcset="/wp-content/uploads/2018/09/pic22-1024x602.png 1024w, /wp-content/uploads/2018/09/pic22-300x176.png 300w, /wp-content/uploads/2018/09/pic22-768x451.png 768w, /wp-content/uploads/2018/09/pic22-830x488.png 830w, /wp-content/uploads/2018/09/pic22-230x135.png 230w, /wp-content/uploads/2018/09/pic22-350x206.png 350w, /wp-content/uploads/2018/09/pic22-480x282.png 480w" sizes="(max-width: 1024px) 100vw, 1024px" /></p>
<p>2-10. CapitalGain 資本獲利</p>
<p>基礎敘述統計</p><pre class="crayon-plain-tag">summary(inputData$CAPITALGAIN)
# Min. 1st Qu.  Median    Mean 3rd Qu.    Max. 
# 0       0       0    1078       0   99999</pre><p>可以發現資料很右偏，至少有75％(第三個四分位數)的資料都是0。</p>
<p>次數分配圖</p><pre class="crayon-plain-tag">ggplot(data = inputData,mapping = aes(x = CAPITALGAIN, fill = ABOVE50K, group = ABOVE50K)) +
  geom_histogram(bins = 10,color = 'black',lwd =0.3, binwidth = 10000) +  # default bins = 30
  stat_bin(binwidth = 10000, geom = "text", color = "white", size = 3.5,
           mapping = aes(label = ..count.., group = ABOVE50K),position=position_stack(vjust=0.5)) +
  scale_fill_brewer(palette="Paired") +
  scale_x_continuous(breaks= seq(0,max(inputData$CAPITALGAIN), 10000))</pre><p>我們可以觀察到，視覺化的資料極右偏，幾乎所有資料都是0</p>
<p><img loading="lazy" class="alignnone size-large wp-image-1577" src="/wp-content/uploads/2018/09/pic23-1024x602.png" alt="logistic regression" width="1024" height="602" srcset="/wp-content/uploads/2018/09/pic23-1024x602.png 1024w, /wp-content/uploads/2018/09/pic23-300x176.png 300w, /wp-content/uploads/2018/09/pic23-768x451.png 768w, /wp-content/uploads/2018/09/pic23-830x488.png 830w, /wp-content/uploads/2018/09/pic23-230x135.png 230w, /wp-content/uploads/2018/09/pic23-350x206.png 350w, /wp-content/uploads/2018/09/pic23-480x282.png 480w" sizes="(max-width: 1024px) 100vw, 1024px" /></p>
<p>看一下capitalgain資料是0的比例：</p><pre class="crayon-plain-tag">sum(inputData$CAPITALGAIN == 0)/length(inputData$CAPITALGAIN)
# [1] 0.9167102</pre><p>2-11. Capital Loss 資本失利</p>
<p>基礎敘述統計</p><pre class="crayon-plain-tag">summary(inputData$CAPITALLOSS)
# Min. 1st Qu.  Median    Mean 3rd Qu.    Max. 
# 0.0     0.0     0.0    87.3     0.0  4356.0</pre><p>次數分配圖</p><pre class="crayon-plain-tag">ggplot(data = inputData,mapping = aes(x = CAPITALLOSS, fill = ABOVE50K, group = ABOVE50K)) +
  geom_histogram(color = 'black',lwd =0.3, binwidth = 1000) +  # default bins = 30
  stat_bin(geom = "text", color = "white", size = 3.5, binwidth = 1000,
           mapping = aes(label = ..count.., group = ABOVE50K),position=position_stack(vjust=0.5)) +
  scale_fill_brewer(palette="Paired")</pre><p><img loading="lazy" class="alignnone size-large wp-image-1578" src="/wp-content/uploads/2018/09/pic24-1024x602.png" alt="logistic regression" width="1024" height="602" srcset="/wp-content/uploads/2018/09/pic24-1024x602.png 1024w, /wp-content/uploads/2018/09/pic24-300x176.png 300w, /wp-content/uploads/2018/09/pic24-768x451.png 768w, /wp-content/uploads/2018/09/pic24-830x488.png 830w, /wp-content/uploads/2018/09/pic24-230x135.png 230w, /wp-content/uploads/2018/09/pic24-350x206.png 350w, /wp-content/uploads/2018/09/pic24-480x282.png 480w" sizes="(max-width: 1024px) 100vw, 1024px" /></p>
<p>看一下CAPITALLOSS資料是0的比例：</p><pre class="crayon-plain-tag">sum(inputData$CAPITALLOSS == 0)/length(inputData$CAPITALLOSS)
# [1] 0.9533491</pre><p>2-12. HOURSPERWEEK</p>
<p>基礎敘述統計</p><pre class="crayon-plain-tag">summary(inputData$HOURSPERWEEK)
# Min. 1st Qu.  Median    Mean 3rd Qu.    Max. 
# 1.00   40.00   40.00   40.44   45.00   99.00</pre><p>次數分配圖</p><pre class="crayon-plain-tag">ggplot(data = inputData,mapping = aes(x = HOURSPERWEEK, fill = ABOVE50K, group = ABOVE50K)) +
  geom_histogram(bins = 10, color = 'black',lwd =0.3) +  # default bins = 30
  stat_bin(geom = "text", color = "white", size = 3.5, bins = 10,
           mapping = aes(label = ..count.., group = ABOVE50K),position=position_stack(vjust=0.5)) +
  scale_fill_brewer(palette="Paired")</pre><p><img loading="lazy" class="alignnone size-large wp-image-1579" src="/wp-content/uploads/2018/09/pic25-1024x602.png" alt="logistic regression" width="1024" height="602" srcset="/wp-content/uploads/2018/09/pic25-1024x602.png 1024w, /wp-content/uploads/2018/09/pic25-300x176.png 300w, /wp-content/uploads/2018/09/pic25-768x451.png 768w, /wp-content/uploads/2018/09/pic25-830x488.png 830w, /wp-content/uploads/2018/09/pic25-230x135.png 230w, /wp-content/uploads/2018/09/pic25-350x206.png 350w, /wp-content/uploads/2018/09/pic25-480x282.png 480w" sizes="(max-width: 1024px) 100vw, 1024px" /></p>
<p>2-13. NATIVECOUNTRY 國籍</p>
<p>次數分配圖</p><pre class="crayon-plain-tag">inputData$NATIVECOUNTRY &lt;- factor(x = inputData$NATIVECOUNTRY,levels = names(sort(table(inputData$NATIVECOUNTRY),decreasing = TRUE)))
ggplot(data = inputData, aes(x = NATIVECOUNTRY, fill = ABOVE50K)) +
  geom_bar() +
  geom_text(stat = "count", aes(label=..count..),size=3.5,position = position_stack(vjust = 0.5)) +
  scale_fill_brewer(palette="Paired") +
  theme(axis.text.x = element_text(angle = 30, hjust = 1))</pre><p><img loading="lazy" class="alignnone size-large wp-image-1580" src="/wp-content/uploads/2018/09/pic26-1024x602.png" alt="logistic regression" width="1024" height="602" srcset="/wp-content/uploads/2018/09/pic26-1024x602.png 1024w, /wp-content/uploads/2018/09/pic26-300x176.png 300w, /wp-content/uploads/2018/09/pic26-768x451.png 768w, /wp-content/uploads/2018/09/pic26-830x488.png 830w, /wp-content/uploads/2018/09/pic26-230x135.png 230w, /wp-content/uploads/2018/09/pic26-350x206.png 350w, /wp-content/uploads/2018/09/pic26-480x282.png 480w" sizes="(max-width: 1024px) 100vw, 1024px" /></p>
<p><span style="color: #9d6ad4;">可以發現資料超偏，都集中在美國，因此不適合投入模型</span>。</p>
<div align="center"><script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><br />
<!-- text & display ads 1 --><br />
<ins class="adsbygoogle" style="display: block;" data-ad-client="ca-pub-7946632597933771" data-ad-slot="8154450369" data-ad-format="auto" data-full-width-responsive="true"></ins><br />
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script></div>
<h3>3. 資料前處理</h3>
<p>3- 1. 類別水準值簡化</p>
<p>OCCUPATION的部分，因為水平值偏多，且沒有替代變數欄位，故我們考慮將此變數水平值簡化。我們將之簡化為以下幾群：<br />
Blue-Collar, Professional, Sales, Service, and White-Collar, Other/Unknown。</p><pre class="crayon-plain-tag"># 先將?改命名成Unknown
levels(inputData$OCCUPATION)[1] &lt;- "Unknown"

# 新增一個replacement水準值後的欄位：
inputData$OCCUPATION_rep &lt;- inputData$OCCUPATION

# (1) Craft-repair, Farming-fishing, Handlers-cleaners , Machine-op-inspct, Transport-moving =&gt; 合併成Blue-Collar
inputData$OCCUPATION_rep &lt;- gsub(pattern = '^ Craft-repair', replacement = 'Blue-Collar', x = inputData$OCCUPATION_rep)
inputData$OCCUPATION_rep &lt;- gsub(pattern = '^ Farming-fishing', replacement = 'Blue-Collar', x = inputData$OCCUPATION_rep)
inputData$OCCUPATION_rep &lt;- gsub(pattern = '^ Handlers-cleaners', replacement = 'Blue-Collar', x = inputData$OCCUPATION_rep)
inputData$OCCUPATION_rep &lt;- gsub(pattern = '^ Machine-op-inspct', replacement = 'Blue-Collar', x = inputData$OCCUPATION_rep)
inputData$OCCUPATION_rep &lt;- gsub(pattern = '^ Transport-moving', replacement = 'Blue-Collar', x = inputData$OCCUPATION_rep)

# (2) Prof-specialty, =&gt; Professional
inputData$OCCUPATION_rep &lt;- gsub(pattern = '^ Prof-specialty', replacement = 'Professional', x = inputData$OCCUPATION_rep)

# (3) Sales =&gt; Sales不變

# (4) Other-service, Priv-house-serv, Protective-serv, Tech-support, =&gt; Service
inputData$OCCUPATION_rep &lt;- gsub(pattern = '^ Other-service', replacement = 'Service', x = inputData$OCCUPATION_rep)
inputData$OCCUPATION_rep &lt;- gsub(pattern = '^ Priv-house-serv', replacement = 'Service', x = inputData$OCCUPATION_rep)
inputData$OCCUPATION_rep &lt;- gsub(pattern = '^ Protective-serv', replacement = 'Service', x = inputData$OCCUPATION_rep)
inputData$OCCUPATION_rep &lt;- gsub(pattern = '^ Tech-support', replacement = 'Service', x = inputData$OCCUPATION_rep)

# (5) Adm-clerical, Exec-managerial =&gt; 合併成White-Collar
inputData$OCCUPATION_rep &lt;- gsub(pattern = '^ Adm-clerical', replacement = 'White-Collar', x = inputData$OCCUPATION_rep)
inputData$OCCUPATION_rep &lt;- gsub(pattern = '^ Exec-managerial', replacement = 'White-Collar', x = inputData$OCCUPATION_rep)
# (6) ?,Armed-Forces =&gt; Other/Unknown
inputData$OCCUPATION_rep &lt;- gsub(pattern = '^Unknown', replacement = 'Other/Unknown', x = inputData$OCCUPATION_rep)
inputData$OCCUPATION_rep &lt;- gsub(pattern = '^ Armed-Forces', replacement = 'Other/Unknown', x = inputData$OCCUPATION_rep)

inputData$OCCUPATION_rep &lt;- as.factor(inputData$OCCUPATION_rep)

summary(inputData$OCCUPATION_rep)
# Sales   Blue-Collar Other/Unknown  Professional       Service  White-Collar 
# 3650         10062          1852          4140          5021          7836
levels(inputData$OCCUPATION_rep)
# [1] " Sales"        "Blue-Collar"   "Other/Unknown" "Professional"  "Service"       "White-Collar"</pre><p>3-2. (optional)產生類別變數的WOE值<span style="color: #9d6ad4;">(本分析不會執行此段程式碼）</span></p><pre class="crayon-plain-tag"># 這是一個選擇性的步驟，我們在本分析不會執行
# factor_vars &lt;- c ("WORKCLASS", "EDUCATION", "MARITALSTATUS", "OCCUPATION", "OCCUPATION_rep", "RELATIONSHIP", "RACE", "SEX", "NATIVECOUNTRY")

# not run
# for(factor_var in factor_vars){
#   inputData[[factor_var]] &lt;- WOE(X = inputData[,factor_var], Y = inputData$ABOVE50K_y)
# }</pre><p></p>
<h3>4. 產生訓練資料集與測試資料集</h3>
<p></p><pre class="crayon-plain-tag"># 產生訓練資料集
input_ones &lt;- inputData[which(inputData$ABOVE50K_y == 1),]
input_zeros &lt;- inputData[which(inputData$ABOVE50K_y == 0), ]
set.seed(100)
input_ones_training_row &lt;- sample(1:nrow(input_ones),0.7*nrow(input_ones))
input_zeros_training_row &lt;- sample(1:nrow(input_zeros),0.7*nrow(input_zeros))

training_ones &lt;- input_ones[input_ones_training_row,]
training_zeros &lt;- input_zeros[input_zeros_training_row,]
trainingData &lt;- rbind(training_ones, training_zeros)

# 產生測試資料集
test_ones &lt;- input_ones[-input_ones_training_row,]
test_zeros &lt;- input_zeros[-input_zeros_training_row,]
testData &lt;- rbind(test_ones, test_zeros)</pre><p></p>
<h3>5. 計算IV值，篩選變數</h3>
<p></p><pre class="crayon-plain-tag"># 我們會使用套件中的函數smbinning::smbinning，來將連續變數切割為類別變數
library(smbinning)
# 將連續型變數和類別型變數分開
# 記得加入"OCCUPATION_rep"
factor_vars &lt;- c ("WORKCLASS", "EDUCATION", "MARITALSTATUS", "OCCUPATION","OCCUPATION_rep", "RELATIONSHIP", "RACE", "SEX", "NATIVECOUNTRY")
continuous_vars &lt;- c("AGE", "FNLWGT","EDUCATIONNUM", "HOURSPERWEEK", "CAPITALGAIN", "CAPITALLOSS")

# 建立一個變數IV值表格 : numeric(參數要放變數行數)
iv_df &lt;- data.frame(VARS = c(factor_vars, continuous_vars), IV = numeric(15))

# 計算類別變數的IV值
for(factor_var in factor_vars){
  smb &lt;- smbinning.factor(df = trainingData ,y = "ABOVE50K_y",x = factor_var)
  if(class(smb) != "character"){
    iv_df[iv_df$VARS == factor_var,"IV"] &lt;- smb$iv
  }
}
# 計算連續變數的IV值
for(continuous_var in continuous_vars){
  smb &lt;- smbinning(df = trainingData,y = "ABOVE50K_y",x = continuous_var)
  if(class(smb) != "character"){
    iv_df[iv_df$VARS == continuous_var,"IV"] &lt;- smb$iv
  }
}

# 將變數依據IV值高低排列
iv_df &lt;- iv_df[order(-iv_df$IV),]
iv_df

# VARS     IV
# 6    RELATIONSHIP 1.5435
# 3   MARITALSTATUS 1.3195
# 10            AGE 1.1815
# 12   EDUCATIONNUM 0.7169
# 14    CAPITALGAIN 0.6849
# 13   HOURSPERWEEK 0.4592
# 5  OCCUPATION_rep 0.3594
# 8             SEX 0.3127
# 1       WORKCLASS 0.1673
# 7            RACE 0.0634
# 2       EDUCATION 0.0000
# 4      OCCUPATION 0.0000
# 9   NATIVECOUNTRY 0.0000
# 11         FNLWGT 0.0000
# 15    CAPITALLOSS 0.0000</pre><p>關於IV Table的部分，我們可以得出以下資訊：</p>
<ol>
<li>根據經驗，IV&gt;=0.3即表示該預測變數與目標變數有較強的關係。</li>
<li>類別變數IV=0表示類別水準值過多。
<ul>
<li>EDUCATION: 可以使用IV值較高的EDUCATIONNUM代替。</li>
<li>NATIVECOUNTRY:如我們一開始在資料探勘時所見，絕大多數資料皆為United States，因此不予進一步討論。</li>
</ul>
</li>
<li>連續變數IV=0表示沒有顯著的切點存在。
<ul>
<li>FNLWGT：一開始為簡化分析，即不考慮納入模型分析。</li>
<li>CAPITALLOSS: 因為該特徵資料分佈極偏，故不納入進一步模型分析。</li>
</ul>
</li>
<li>從IV表數值，我們決定初步篩選出變數RELATIONSHIP, MARITALSTATUS, AGE, EDUCATIONNUM, CAPITALGAIN, OCCUPATION_rep進行模型分析。</li>
</ol>
<p>Logistic Regression Modeling <span style="color: #9f6ad4;">羅吉斯回歸建模 part2 </span>的部分請參考: <a href="/logistic_regression_part2/" target="_blank" rel="noopener noreferrer">羅吉斯回歸 &#8211; part2 模型建置、診斷與比較</a>。</p>
<div align="center"><script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><br />
<!-- text & display ads 1 --><br />
<ins class="adsbygoogle" style="display: block;" data-ad-client="ca-pub-7946632597933771" data-ad-slot="8154450369" data-ad-format="auto" data-full-width-responsive="true"></ins><br />
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script></div>
<hr />
<p>更多模型建置筆記連結：</p>
<ol>
<li><a href="/logistic-regression-part2-%e7%be%85%e5%90%89%e6%96%af%e8%bf%b4%e6%ad%b8/" target="_blank" rel="noopener noreferrer">Logistic Regression 羅吉斯迴歸 | part2 &#8211; 模型建置、診斷與比較 | R語言</a></li>
<li><a href="/linear-regression-%e7%b7%9a%e6%80%a7%e8%bf%b4%e6%ad%b8%e6%a8%a1%e5%9e%8b/" target="_blank" rel="noopener noreferrer">Linear Regression | 線性迴歸模型 | using AirQuality Dataset</a></li>
<li><a href="/regularized-regression-ridge-lasso-elastic/" target="_blank" rel="noopener noreferrer">Regularized Regression | 正規化迴歸 &#8211; Ridge, Lasso, Elastic Net | R語言</a></li>
<li><a href="/decision-tree-cart-%e6%b1%ba%e7%ad%96%e6%a8%b9/" target="_blank" rel="noopener noreferrer">Decision Tree 決策樹 | CART, Conditional Inference Tree, Random Forest</a></li>
<li><a href="/regression-tree-%e8%bf%b4%e6%ad%b8%e6%a8%b9-bagging-bootstrap-aggrgation-r%e8%aa%9e%e8%a8%80/" target="_blank" rel="noopener noreferrer">Regression Tree | 迴歸樹, Bagging, Bootstrap Aggregation | R語言</a></li>
<li><a href="/random-forests-%e9%9a%a8%e6%a9%9f%e6%a3%ae%e6%9e%97/" target="_blank" rel="noopener noreferrer">Random Forests 隨機森林 | randomForest, ranger, h2o | R語言</a></li>
<li><a href="/gradient-boosting-machines-gbm/" target="_blank" rel="noopener noreferrer">Gradient Boosting Machines GBM | gbm, xgboost, h2o | R語言</a></li>
<li><a href="/hierarchical-clustering-%e9%9a%8e%e5%b1%a4%e5%bc%8f%e5%88%86%e7%be%a4/" target="_blank" rel="noopener noreferrer">Hierarchical Clustering 階層式分群 | Clustering 資料分群 | R統計</a></li>
<li><a href="/partitional-clustering-kmeans-kmedoid/" target="_blank" rel="noopener noreferrer">Partitional Clustering | 切割式分群 | Kmeans, Kmedoid | Clustering 資料分群</a></li>
<li><a href="/principal-components-analysis-pca-%e4%b8%bb%e6%88%90%e4%bb%bd%e5%88%86%e6%9e%90/" target="_blank" rel="noopener noreferrer">Principal Components Analysis (PCA) | 主成份分析 | R 統計</a></li>
</ol>
<hr />
<p>參考:</p>
<ol>
<li><a href="https://tinyurl.com/y796qqca">歐萊禮  R資料科學</a></li>
</ol>
<p>這篇文章 <a rel="nofollow" href="/logistic-regression-part1-%e7%be%85%e5%90%89%e6%96%af%e8%bf%b4%e6%ad%b8/">Logistic Regression 羅吉斯迴歸 | part1 &#8211; 資料探勘與處理 | 統計 R語言</a> 最早出現於 <a rel="nofollow" href="/">果醬珍珍•JamJam</a>。</p>
]]></content:encoded>
					
					<wfw:commentRss>/logistic-regression-part1-%e7%be%85%e5%90%89%e6%96%af%e8%bf%b4%e6%ad%b8/feed/</wfw:commentRss>
			<slash:comments>2</slash:comments>
		
		
			</item>
	</channel>
</rss>
